# GMC 资源打包指南

## 概述

GMC 框架支持将**视图模板**、**国际化文件**、**静态资源**等打包进二进制文件，无需在部署时携带这些文件。这使得应用部署更加简单，只需一个可执行文件即可运行。

本指南将介绍如何使用 Go 1.16+ 的 `embed` 包实现资源打包的最佳实践。

## 核心原理

GMC 提供了三种资源的打包支持：

1. **视图模板** - 通过 `gtemplate.SetBinBytes()` / `gtemplate.SetBinBase64()` / `gtemplate.NewEmbedTemplateFS()`
2. **国际化文件** - 通过 `gi18n.SetBinData()` / `gi18n.InitEmbedFS()`
3. **静态资源** - 通过 `HTTPServer.ServeEmbedFS()` / `HTTPServer.ServeEmbedFSWithFilter()`

所有方法都支持从 Go 的 `embed.FS` 加载资源。

## 使用 embed 打包

Go 1.16+ 提供了内置的 `embed` 包，这是最简单、最推荐的方式。

### 1. 打包视图模板

#### 步骤 1：创建视图包

创建 `views/views.go` 文件：

```go
package views

import (
	"embed"
)

// ViewFiles 视图文件（打包时自动嵌入）
//
//go:embed *
var ViewFiles embed.FS
```

**说明：**
- `//go:embed *` 会嵌入 `views/` 目录下的所有文件
- 也可以指定特定模式，如 `//go:embed *.html` 只嵌入 HTML 文件
- 如果有子目录，使用 `//go:embed **/*.html` 递归嵌入

#### 步骤 2：在主程序中使用

```go
package main

import (
	"github.com/yourapp/views"
	"github.com/snail007/gmc"
	gtemplate "github.com/snail007/gmc/http/template"
)

func main() {
	app := gmc.New.App()
	
	app.AddService(gcore.ServiceItem{
		Service: gmc.New.HTTPServer(app.Ctx()).(gcore.Service),
		AfterInit: func(s *gcore.ServiceItem) error {
			httpServer := s.Service.(*gmc.HTTPServer)
			
			// 使用嵌入的模板
			tpl := gtemplate.NewEmbedTemplateFS(
				httpServer.Tpl().(*gtemplate.Template),
				views.ViewFiles,
				".", // 根目录
			)
			
			// 解析模板
			err := tpl.Parse()
			if err != nil {
				return err
			}
			
			return nil
		},
	})
	
	app.Run()
}
```

**关键点：**
- `NewEmbedTemplateFS()` 会自动将 embed.FS 中的文件转换为模板的 binData
- 调用 `tpl.Parse()` 后，模板会从内存加载，而非磁盘
- 必须在 HTTP Server 启动前调用 `tpl.Parse()`

### 2. 打包国际化文件

#### 步骤 1：创建 i18n 包

创建 `i18n/i18n.go` 文件：

```go
package i18n

import (
	"embed"
)

// I18nFiles 国际化文件（打包时自动嵌入）
//
//go:embed *.toml
var I18nFiles embed.FS
```

**说明：**
- `//go:embed *.toml` 只嵌入当前目录的 `.toml` 文件
- 通常 i18n 文件命名为 `zh-CN.toml`, `en-US.toml` 等

#### 步骤 2：在主程序中使用

```go
package main

import (
	"github.com/yourapp/i18n"
	"github.com/snail007/gmc"
	gi18n "github.com/snail007/gmc/module/i18n"
)

func main() {
	app := gmc.New.App()
	
	app.OnRun(func(config gcore.Config) error {
		// 初始化嵌入的 i18n 文件
		err := gi18n.InitEmbedFS(i18n.I18nFiles, "zh-CN")
		if err != nil {
			return err
		}
		
		// 将 i18n 实例设置到应用上下文
		app.Ctx().SetI18n(gi18n.I18N)
		
		return nil
	})
	
	app.Run()
}
```

**关键点：**
- `InitEmbedFS()` 第二个参数是默认语言
- 必须调用 `SetI18n()` 才能在 Controller 中使用国际化功能
- 建议在 `OnRun` Hook 中初始化，确保在服务启动前完成

### 3. 打包静态资源

#### 步骤 1：创建静态资源包

创建 `static/static.go` 文件：

```go
package static

import (
	"embed"
)

// StaticFiles 静态文件（打包时自动嵌入）
//
//go:embed *
var StaticFiles embed.FS
```

#### 步骤 2：在主程序中使用

**方法 A：直接挂载所有文件**

```go
httpServer.ServeEmbedFS(static.StaticFiles, "/static")
```

**方法 B：使用过滤器（推荐）**

```go
httpServer.ServeEmbedFSWithFilter(
	static.StaticFiles,
	"/static",
	func(r *http.Request, filePath string) (newPath string, ok bool) {
		// 过滤 .go 文件，防止源码泄露
		if filepath.Ext(filePath) == ".go" {
			return "", false
		}
		return filePath, true
	},
)
```

**关键点：**
- `ServeEmbedFS()` 会将整个 embed.FS 挂载到指定路径
- 使用过滤器可以排除不需要的文件（如 `.go` 源文件）
- 静态文件访问路径为 `/static/xxx`

### 完整示例（推荐架构）

项目参考目录结构：

```
yourapp/
├── cmd/
│   └── yourapp/
│       └── main.go          # 主程序
├── views/
│   ├── views.go             # 视图嵌入包
│   ├── admin.html
│   └── login.html
├── static/
│   ├── static.go            # 静态资源嵌入包
│   ├── css/
│   ├── js/
│   └── images/
├── i18n/
│   ├── i18n.go              # 国际化嵌入包
│   ├── zh-CN.toml
│   └── en-US.toml
├── conf/
│   └── app.toml             # 配置文件
└── go.mod
```

**main.go 完整示例：**

```go
package main

import (
	"net/http"
	"path/filepath"
	
	"github.com/yourapp/i18n"
	"github.com/yourapp/static"
	"github.com/yourapp/views"
	"github.com/snail007/gmc"
	gcore "github.com/snail007/gmc/core"
	gtemplate "github.com/snail007/gmc/http/template"
	gi18n "github.com/snail007/gmc/module/i18n"
)

func main() {
	app := gmc.New.App()
	app.SetConfigFile("conf/app.toml")
	
	// OnRun Hook：初始化国际化
	app.OnRun(func(config gcore.Config) error {
		// 初始化 i18n
		err := gi18n.InitEmbedFS(i18n.I18nFiles, "zh-CN")
		if err != nil {
			return err
		}
		app.Ctx().SetI18n(gi18n.I18N)
		
		return nil
	})
	
	// 添加 HTTP 服务
	app.AddService(gcore.ServiceItem{
		Service: gmc.New.HTTPServer(app.Ctx()).(gcore.Service),
		AfterInit: func(s *gcore.ServiceItem) error {
			httpServer := s.Service.(*gmc.HTTPServer)
			
			// 1. 注册静态文件
			httpServer.ServeEmbedFSWithFilter(
				static.StaticFiles,
				"/static",
				func(r *http.Request, filePath string) (string, bool) {
					if filepath.Ext(filePath) == ".go" {
						return "", false
					}
					return filePath, true
				},
			)
			
			// 2. 注册模板文件
			tpl := gtemplate.NewEmbedTemplateFS(
				httpServer.Tpl().(*gtemplate.Template),
				views.ViewFiles,
				".",
			)
			err := tpl.Parse()
			if err != nil {
				return err
			}
			
			// 3. 其他初始化...
			
			return nil
		},
	})
	
	app.Run()
}
```

## 配置文件说明（重要）

使用 embed 打包资源后，配置文件中的某些路径配置需要特别注意。

### 模板配置（app.toml）

```toml
[template]
# ⚠️ 重要：使用 embed 打包后，必须设置为空字符串
# 如果不设置为空，GMC 会尝试从磁盘加载模板，导致打包失败或运行时找不到文件
dir = ""

# 模板文件扩展名（仍然有效）
ext = ".html"

# 左定界符（仍然有效）
delimiterleft = "{{"

# 右定界符（仍然有效）
delimiterright = "}}"

# 布局目录（可选）
layout = ""
```

**关键配置说明：**

| 配置项 | 使用 embed 时 | 说明 |
|-------|--------------|------|
| `dir` | **必须为空** `""` | 否则会尝试从磁盘加载 |
| `ext` | 保持不变 | 扩展名配置仍然有效 |
| `delimiterleft` | 保持不变 | 定界符配置仍然有效 |
| `delimiterright` | 保持不变 | 定界符配置仍然有效 |
| `layout` | 保持不变 | 布局目录配置仍然有效 |

### 静态资源配置（app.toml）

```toml
[static]
# ⚠️ 重要：使用 embed 打包后，必须设置为空字符串
# 如果不为空，GMC 会尝试从磁盘加载静态文件
dir = ""

# urlpath 也应该设置为空，因为我们在代码中手动注册
urlpath = ""
```

**说明：**
- `static.dir` 必须为空，否则 GMC 会尝试从磁盘加载静态文件
- `static.urlpath` 设置为空，因为我们通过 `ServeEmbedFS()` 手动指定路径

### 国际化配置（app.toml）

```toml
[i18n]
# 必须禁用
enable = false

# ⚠️ 重要：使用 embed 打包后，必须设置为空字符串
# 因为我们在代码中使用 InitEmbedFS() 初始化
dir = ""

# 默认语言（enable=false，这个配置无效）
default = "zh-CN"
```

**说明：**
- 如果使用 `gi18n.InitEmbedFS()` 初始化，必须设置 `enable = false`
- 必须设置 `dir = ""`
- `default` 语言在 `InitEmbedFS()` 中手动指定

### 完整配置示例（embed 打包模式）

参考配置：

```toml
#....

[static]
# 使用 embed 打包，必须为空
dir = ""
urlpath = ""

[template]
# 使用 embed 打包，必须为空
dir = ""
ext = ".html"
# 使用自定义定界符
delimiterleft = "#!"
delimiterright = "!#"
layout = "layout"

[i18n]
# 使用 InitEmbedFS() 初始化，禁用配置文件加载
enable = false
dir = ""
default = "zh-CN"

#....

```

### 配置文件检查清单

使用 embed 打包前，请确认以下配置：

- [ ] `[template]` → `dir = ""`
- [ ] `[static]` → `dir = ""` 和 `urlpath = ""`
- [ ] `[i18n]` → `enable = false` 和 `dir = ""`
- [ ] 其他配置（如扩展名、定界符）根据需要设置

**⚠️ 常见错误：**

```toml
# ❌ 错误：dir 不为空，会导致运行时尝试从磁盘加载
[template]
dir = "views"

# ✅ 正确：dir 为空，使用 embed 加载
[template]
dir = ""
```

### 自定义模板定界符

如果模板中使用了 Vue.js、Angular 等前端框架，建议修改定界符：

```toml
[template]
delimiterleft = "#!"
delimiterright = "!#"
```

```go
// 强制设置模板分隔符
httpServer.Tpl().Delims("#!", "!#")
```

模板中使用：

```html
<h1>#! .title !#</h1>
<div id="app">
    <!-- Vue.js 可以正常使用 {{}} -->
    {{ message }}
</div>
```

## 最佳实践

### 1. 目录结构

```
yourapp/
├── cmd/yourapp/main.go      # 主程序
├── views/                   # 视图目录
│   ├── views.go             # embed 包
│   └── *.html               # 模板文件
├── static/                  # 静态资源目录
│   ├── static.go            # embed 包
│   ├── css/
│   ├── js/
│   └── images/
├── i18n/                    # 国际化目录
│   ├── i18n.go              # embed 包
│   └── *.toml               # 语言文件
└── conf/app.toml            # 配置文件
```

### 2. embed 包命名规范

每个资源目录创建一个同名 `.go` 文件：

- `views/views.go` - 导出 `ViewFiles`
- `static/static.go` - 导出 `StaticFiles`
- `i18n/i18n.go` - 导出 `I18nFiles`

### 3. 静态文件过滤器

**始终使用过滤器排除源码文件：**

```go
httpServer.ServeEmbedFSWithFilter(
	static.StaticFiles,
	"/static",
	func(r *http.Request, filePath string) (string, bool) {
		ext := filepath.Ext(filePath)
		// 排除源码文件
		if ext == ".go" || ext == ".mod" || ext == ".sum" {
			return "", false
		}
		return filePath, true
	},
)
```

### 4. 初始化顺序

正确的初始化顺序：

1. **OnRun Hook** 中初始化国际化
2. **AfterInit** 中注册静态文件
3. **AfterInit** 中解析模板文件
4. **AfterInit** 中执行其他初始化

示例：

```go
app.OnRun(func(config gcore.Config) error {
	// 1. 初始化国际化
	gi18n.InitEmbedFS(i18n.I18nFiles, "zh-CN")
	app.Ctx().SetI18n(gi18n.I18N)
	return nil
})

app.AddService(gcore.ServiceItem{
	Service: gmc.New.HTTPServer(app.Ctx()).(gcore.Service),
	AfterInit: func(s *gcore.ServiceItem) error {
		httpServer := s.Service.(*gmc.HTTPServer)
		
		// 2. 注册静态文件
		httpServer.ServeEmbedFS(static.StaticFiles, "/static")
		
		// 3. 解析模板
		tpl := gtemplate.NewEmbedTemplateFS(...)
		tpl.Parse()
		
		// 4. 其他初始化
		// ...
		
		return nil
	},
})
```

## 部署

编译后只需部署：

```
yourapp-linux-amd64  # 可执行文件
conf/app.toml        # 配置文件（如果不嵌入）
```

所有视图、静态资源、国际化文件都已打包在二进制中。

## 常见问题

### 1. 模板路径问题

**问题：** 使用 embed 后找不到模板

**解决：**
- **检查配置文件**：确保 `template.dir = ""`（必须为空字符串）
- 确保 `//go:embed` 指令正确
- 检查 `NewEmbedTemplateFS()` 的根目录参数
- 使用 `tpl.Parse()` 前检查错误
- 确保在 HTTP Server 启动前调用 `tpl.Parse()`

**常见错误示例：**
```toml
# ❌ 错误：template.dir 不为空
[template]
dir = "views"  # 这会导致从磁盘加载，而不是从 embed

# ✅ 正确
[template]
dir = ""  # 必须为空，才会使用 embed 的数据
```

### 2. 静态文件 404

**问题：** 静态文件无法访问

**解决：**
- **检查配置文件**：确保 `static.dir = ""` 和 `static.urlpath = ""`（必须为空）
- 检查 `ServeEmbedFS()` 的路径参数
- 确认文件已被 embed（检查编译输出）
- 使用过滤器时检查返回值

**常见错误示例：**
```toml
# ❌ 错误：static 配置不为空
[static]
dir = "static"
urlpath = "/static/"

# ✅ 正确
[static]
dir = ""
urlpath = ""
```

### 3. 国际化不生效

**问题：** 翻译函数返回原始 key

**解决：**
- **检查配置文件**：如果使用 `InitEmbedFS()`，必须设置 `i18n.enable = false` 和 `i18n.dir = ""`
- 确保调用了 `app.Ctx().SetI18n(gi18n.I18N)`
- 检查 TOML 文件格式
- 确认默认语言设置正确
- 确保在 `OnRun` Hook 中初始化，早于 HTTP Server 启动

**配置示例：**
```toml
# 使用 InitEmbedFS() 时的推荐配置
[i18n]
enable = false  # 禁用配置文件加载
dir = ""        # 必须为空
default = "zh-CN"
```

### 4. 二进制体积过大

**问题：** 打包后二进制文件过大

**解决：**
- 使用 `-ldflags "-s -w"` 去除调试信息
- 压缩静态资源（CSS、JS、图片）
- 考虑使用 CDN 托管大文件
- 使用 `upx` 工具进一步压缩

```bash
# 编译
go build -ldflags "-s -w" -o yourapp

# 使用 upx 压缩
upx --brute yourapp
```

## 参考资料

### GMC 源码

- **模板模块**: `http/template/template.go`
- **国际化模块**: `module/i18n/i18n.go`
- **HTTP Server**: `http/server/server.go`

### 相关文档

- [GMC 模板文档](http/template/README.md)
- [Go embed 官方文档](https://pkg.go.dev/embed)
- [GMC 框架主页](https://github.com/snail007/gmc)

## 总结

使用 Go 1.16+ 的 `embed` 包是打包资源的最佳实践：

1. **简单易用** - 无需额外脚本，Go 编译器自动处理
2. **类型安全** - embed.FS 是标准库类型
3. **性能优秀** - 资源直接嵌入二进制，无需运行时解码
4. **开发友好** - 可以轻松切换开发/生产模式

### 关键配置要点（必读）

使用 embed 打包时，**务必修改配置文件**：

```toml
# ⚠️ 三个核心配置必须设置为空字符串
[template]
dir = ""  # 必须为空

[static]
dir = ""      # 必须为空
urlpath = ""  # 必须为空

[i18n]
enable = false  # 必须禁用
dir = ""        # 必须为空
```

推荐的资源打包架构：

```go
// 1. 在资源目录创建 embed 包
package views
//go:embed *
var ViewFiles embed.FS

// 2. 修改配置文件（重要！）
// conf/app.toml:
// [template]
// dir = ""  # 必须为空

// 3. 在 OnRun 中初始化国际化
app.OnRun(func(config gcore.Config) error {
    gi18n.InitEmbedFS(i18n.I18nFiles, "zh-CN")
    app.Ctx().SetI18n(gi18n.I18N)
    return nil
})

// 4. 在 AfterInit 中注册资源
app.AddService(gcore.ServiceItem{
    AfterInit: func(s *gcore.ServiceItem) error {
        httpServer.ServeEmbedFS(static.StaticFiles, "/static")
        tpl := gtemplate.NewEmbedTemplateFS(httpServer.Tpl(), views.ViewFiles, ".")
        return tpl.Parse()
    },
})
```

这样就能实现**单一二进制部署**，极大简化生产环境的运维工作。

### 快速检查清单

打包前请确认：

- [ ] `views/views.go` - 创建 embed 包
- [ ] `static/static.go` - 创建 embed 包
- [ ] `i18n/i18n.go` - 创建 embed 包
- [ ] **配置文件 `[template]` → `dir = ""`**
- [ ] **配置文件 `[static]` → `dir = ""` 和 `urlpath = ""`**
- [ ] **配置文件 `[i18n]` → `enable = false` 和 `dir = ""`**
- [ ] 代码中调用 `tpl.Parse()`
- [ ] 代码中调用 `app.Ctx().SetI18n(gi18n.I18N)`
